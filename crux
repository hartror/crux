#!/usr/bin/python
#
#   crux -- a utility for creating keystone objects
#   Copyright (C) 2013 Lars Kellogg-Stedman <lars@oddbit.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


import os
import sys
import argparse
import yaml
import random
import string
import logging

from keystoneclient.v2_0 import client
import keystoneclient.exceptions

args     = None
keystone = None
log      = None

def find_or_create_role(role):
    '''Given a role name (as {'name': rolename}), find it or create it if
    it doesn't exist and return the role object to the caller.'''

    assert 'name' in role

    try:
        that = keystone.roles.find(name=role['name'])
        log.info('found role %(name)s', role)
    except keystoneclient.exceptions.NotFound:
        log.warn('creating role %(name)s', role)
        that = keystone.roles.create(role['name'])

    return that

def find_or_create_tenant(tenant):
    '''Given a tenant name (as {'name': tenantname}), find it or create it if
    it doesn't exist and return the tenant object to the caller.'''

    assert 'name' in tenant

    try:
        that = keystone.tenants.find(name=tenant['name'])
        log.info('found tenant %(name)s', tenant)
    except keystoneclient.exceptions.NotFound:
        log.warn('creating tenant %(name)s', tenant)
        that = keystone.tenants.create(tenant['name'],
                description=tenant.get('description'),
                enabled=(tenant.get('enabled', True)))

    return that

def find_or_create_user(user, tenant, role):
    '''Given a user name (as {'name': username}), find it or create it if
    it doesn't exist and return the user object to the caller.  The 'user'
    dictionary may also contain a 'password' key; if no such key exists a
    random password will be generated for the user.  The 'user' dictionary
    may also contain an 'email' key; if no such key exists the email field
    will default to the user name.
    
    The user will be added to 'tenant' as their primary tenant, and if
    role is defined the user will be assigned that role.'''

    global args

    assert 'name' in user
    assert tenant is not None

    password = user.get('password')
    if not password:
        password = ''.join(
                random.sample(string.letters + string.digits, args.pwlen))

    try:
        that = keystone.users.find(name=user['name'])
        log.info('found user %(name)s', user)
        keystone.users.update_password(that, password)
        log.warn('set password for user %s to %s', user['name'], password)
    except keystoneclient.exceptions.NotFound:
        log.warn('creating user %s with password %s', user['name'], password)
        that = keystone.users.create(
                user['name'],
                password,
                user.get('email', user['name']),
                tenant_id = tenant.id,
                enabled=(user.get('enabled', True)))

    if role and not role in keystone.roles.roles_for_user(that, tenant):
        keystone.roles.add_user_role(that, role, tenant)
        log.warn('added role %s to user %s', role.name, that.name)

    return that

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument('--config', '-f')
    p.add_argument('--user', '-u',
            action='append',
            default=[],
            help='Given <user>:<tenant>:<role>:<password>, create <tenant> if '\
                    'necessary, create <user> if necessary, create <role> '\
                    'if necessary, assign <role> to <user> and set the '\
                    'password for <user> to <password>')
    p.add_argument('--role', '-r',
            action='append',
            default=[],
            help='Create <role> if it does not already exist')
    p.add_argument('--tenant', '-t',
            action='append',
            default=[],
            help='Create <tenant> if it does not already exist')
    p.add_argument('--pwlen', help='Length of generated passwords.',
            default=12)
    p.add_argument('--verbose', '-v', action='store_true',
            help='Enable verbose logging')
    return p.parse_args()


def setup_logging():
    global args
    global log


    logging.basicConfig(
            level = logging.WARN,
            format='%(asctime)s %(name)s %(levelname)s %(message)s',
            datefmt='%Y-%m-%d',
            )

    log = logging.getLogger('crux')
    log.setLevel(logging.INFO if args.verbose else logging.WARN)

def setup_keystone():
    global args
    global keystone

    keystone = client.Client(
            username=os.environ['OS_USERNAME'],
            password=os.environ['OS_PASSWORD'],
            tenant_name=os.environ['OS_TENANT_NAME'],
            auth_url=os.environ['OS_AUTH_URL'])

def main():
    global args

    cf = {}
    args = parse_args()
    setup_logging()

    if args.config:
        with open(args.config) as fd:
            cf = yaml.load(fd).get('keystone')

    setup_keystone()

    for section in [ 'users', 'roles', 'tenants' ]:
        if not section in cf:
            cf[section] = []

    for tenantname in args.tenant:
        cf['tenants'].append({'name': tenantname})
    
    for rolename in args.role:
        cf['roles'].append({'name': rolename})

    for userspec in args.user:
        username, tenantname, role, password = userspec.split(':')
        cf['users'].append({
            'name': username,
            'tenant': tenantname,
            'role': role,
            'password': password,
            })

    for tenant in cf['tenants']:
        tenant = find_or_create_tenant(tenant)

    for role in cf['roles']:
        role = find_or_create_role(role)

    for user in cf['users']:
        assert 'tenant' in user
        assert 'name' in user

        tenant = find_or_create_tenant({'name': user['tenant']})

        if user.get('role'):
            role = find_or_create_role({'name': user['role']})
        else:
            role = None

        user = find_or_create_user(user, tenant, role)

if __name__ == '__main__':
    main()


